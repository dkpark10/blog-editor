{"componentChunkName":"component---src-templates-blog-post-js","path":"/zustands는 어떻게 root provider 없이 상태관리를 할 수 있을까?/","result":{"data":{"site":{"siteMetadata":{"title":"wkd2ev"}},"markdownRemark":{"id":"9989787e-ba3f-5dbd-a3ff-c327cdcaf122","excerpt":"redux, recoil과는 다르게 zustand는 어떻게 root provider 없이 상태관리를 하는지\n궁금했다. 아래는 리덕스 공식문서 튜토리얼에서 가져온 예제이다.\nhttps://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react…","html":"<p>redux, recoil과는 다르게 zustand는 어떻게 root provider 없이 상태관리를 하는지\n궁금했다.</p>\n<p>아래는 리덕스 공식문서 튜토리얼에서 가져온 예제이다.\n<a href=\"https://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react/#passing-the-store-with-provider\">https://ko.redux.js.org/tutorials/fundamentals/part-5-ui-react/#passing-the-store-with-provider</a></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport { Provider } from &#39;react-redux&#39;\n\nimport App from &#39;./App&#39;\nimport store from &#39;./store&#39;\n\nReactDOM.render(\n  // Render a `&lt;Provider&gt;` around the entire `&lt;App&gt;`,\n  // and pass the Redux store to as a prop\n  &lt;React.StrictMode&gt;\n    &lt;Provider store={store}&gt; &lt;-------------------------- provider\n      &lt;App /&gt;\n    &lt;/Provider&gt;\n  &lt;/React.StrictMode&gt;,\n  document.getElementById(&#39;root&#39;)\n)</code>\n        </deckgo-highlight-code>\n<p>아래는 recoil 예제이다.\n<a href=\"https://recoiljs.org/ko/docs/introduction/getting-started\">https://recoiljs.org/ko/docs/introduction/getting-started</a></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\nimport {\n  RecoilRoot,\n  atom,\n  selector,\n  useRecoilState,\n  useRecoilValue,\n} from &#39;recoil&#39;;\n\nfunction App() {\n  return (\n    &lt;RecoilRoot&gt;      &lt;-------------------------- provider\n      &lt;CharacterCounter /&gt;\n    &lt;/RecoilRoot&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇듯 전역상태 라이브러리는 앱의 최상단에 위치하여 상태를 관리한다.\n<a href=\"https://www.slash.page/ko/libraries/react/use-overlay/src/useOverlay.i18n\">https://www.slash.page/ko/libraries/react/use-overlay/src/useOverlay.i18n</a>\ntoss에서 만든 modal을 선언적으로 관리하기 위한 훅도 최상단에서 모달을 관리한다. 아래는 useOverlay의 root provider 코드이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">/** @tossdocs-ignore */\nimport React, { createContext, PropsWithChildren, ReactNode, useCallback, useMemo, useState } from &#39;react&#39;;\n\nexport const OverlayContext = createContext&lt;{\n  mount(id: string, element: ReactNode): void;\n  unmount(id: string): void;\n} | null&gt;(null);\nif (process.env.NODE_ENV !== &#39;production&#39;) {\n  OverlayContext.displayName = &#39;OverlayContext&#39;;\n}\n\nexport function OverlayProvider({ children }: PropsWithChildren) {\n  const [overlayById, setOverlayById] = useState&lt;Map&lt;string, ReactNode&gt;&gt;(new Map()); // &lt;------- 여기서 모달 관리\n\n  const mount = useCallback((id: string, element: ReactNode) =&gt; {\n    setOverlayById(overlayById =&gt; {\n      const cloned = new Map(overlayById);\n      cloned.set(id, element);\n      return cloned;\n    });\n  }, []);\n\n  const unmount = useCallback((id: string) =&gt; {\n    setOverlayById(overlayById =&gt; {\n      const cloned = new Map(overlayById);\n      cloned.delete(id);\n      return cloned;\n    });\n  }, []);\n\n  const context = useMemo(() =&gt; ({ mount, unmount }), [mount, unmount]);\n\n  return (\n    &lt;OverlayContext.Provider value={context}&gt;\n      {children}\n      {[...overlayById.entries()].map(([id, element]) =&gt; (\n        &lt;React.Fragment key={id}&gt;{element}&lt;/React.Fragment&gt;\n      ))}\n    &lt;/OverlayContext.Provider&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇듯 전역으로 상태를 관리 하기 위해서는 최상단 루트 컴포넌트에 상태를 선언하고 이를 children으로 받아서 관리해주고 있다.\n그러나 zustand는 root provider 없이 바로 컴포넌트에서 바로 사용할 수 있다. 이는 어떻게 가능한 것인가.</p>\n<h2>zustand 코드 파헤쳐 보기</h2>\n<p>핵심 로직은 생각보다 간단했다. 코드라인도 길지 않았다. 먼저 사용법은 다음과 같다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { create } from &#39;zustand&#39;\n\nconst useStore = create((set) =&gt; ({\n  count: 1,\n  inc: () =&gt; set((state) =&gt; ({ count: state.count + 1 })),\n}))</code>\n        </deckgo-highlight-code>\n<p>아래는 zustand의 타입과 불필요한 코드를 제거한 가져온 핵심 코드들이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import useSyncExternalStoreExports from &#39;use-sync-external-store/shim/with-selector&#39;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports\n\nconst createStore = (createState) =&gt; {\n  let state\n  const listeners = new Set()\n\n  const setState = (partial, replace) =&gt; {\n    // TODO: Remove type assertion once https://github.com/microsoft/TypeScript/issues/37663 is resolved\n    // https://github.com/microsoft/TypeScript/issues/37663#issuecomment-759728342\n    const nextState =\n      typeof partial === &#39;function&#39;\n        ? partial(state)\n        : partial\n    if (!Object.is(nextState, state)) {\n      const previousState = state\n      state =\n        replace ?? (typeof nextState !== &#39;object&#39; || nextState === null)\n          ? nextState\n          : Object.assign({}, state, nextState)\n      listeners.forEach((listener) =&gt; listener(state, previousState))\n    }\n  }\n\n  const getState = () =&gt; state\n\n  const getInitialState = () =&gt; initialState\n\n  const subscribe = (listener) =&gt; {\n    listeners.add(listener)\n    // Unsubscribe\n    return () =&gt; listeners.delete(listener)\n  }\n\n  const destroy = () =&gt; {\n    listeners.clear()\n  }\n\n  const api = { setState, getState, getInitialState, subscribe, destroy }\n  const initialState = (state = createState(setState, getState, api))\n  return api;\n}\n\nexport function useStore(\n  api,\n  selector,\n  equalityFn?,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn,\n  )\n  return slice\n}\n\nconst createImpl = (createState) =&gt; {\n  const api =\n    typeof createState === &#39;function&#39; ? createStore(createState) : createState\n\n  const useBoundStore = (selector, equalityFn) =&gt;\n    useStore(api, selector, equalityFn)\n\n  Object.assign(useBoundStore, api)\n\n  return useBoundStore\n}\n\nexport const create = ((createState) =&gt; createState ? createImpl(createState) : createImpl);</code>\n        </deckgo-highlight-code>\n<p>정말이지 이게 끝이다. 물론 기타 타입코드와 여러가지가 다른 코드가 존재하지만 핵심은 이것이다.\n먼저 createStore의 코드를 살펴보자.</p>\n<p>zustand는 observer pattern을 사용한다. 프론트엔드에서 빠질 수 없는 패턴이랴\n여기서 listener 함수를 받는데 아래 listener함수가 어디서 왔는지 서술하겠다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const setState = (partial, replace) =&gt; {\n  const nextState = 생략;\n  listeners.forEach((listener) =&gt; listener(state, previousState))\n}\n\nconst getState = () =&gt; state\n\nconst getInitialState = () =&gt; initialState\n\nconst subscribe = (listener) =&gt; {\n  listeners.add(listener)\n  // Unsubscribe\n  return () =&gt; listeners.delete(listener)\n  }</code>\n        </deckgo-highlight-code>\n<p>처음 컴포넌트가 마운트 되었을 때 subscribe 함수가 호출된다. 그 이후에 상태를 업데이트 할 때 마다 리스너들을 순회하여\n리스너 함수를 호출한다. 이렇게 api 객체를 만들어 useSyncExternalStoreWithSelector의 파라미터로 넘긴다.</p>\n<h2>useSyncExternalStore</h2>\n<p>react 18이 릴리즈 되면서 나온 훅이다. 해당 게시글에서 useSyncExternalStore를 깊게 설명할 것은 아니고\n어쨌든 해당 훅은 외부 스토어와의 tearing 현상을 막기 위해 리액트 내부와 싱크를 맞추는 훅이다.</p>\n<p><a href=\"https://www.youtube.com/watch?v=KEDUqA9JeIo\">https://www.youtube.com/watch?v=KEDUqA9JeIo</a>\n위 영상에서 useSyncExternalStore를 사용하여 커스텀 상태관리를 만들고 있다.</p>\n<p>useSyncExternalStore은 첫번째 인자로 subscribe 함수를 받고 있다. 두번쨰 파라미터로는 해당 상태의 스냅샷을 받는 함수를 받고있다.\n여기서 두번쨰 파라미터로 상태 객체를 전달하는게 아닌 함수 형태로 () => state 전달해야 하는데 이는 클로져의 특성을 활용하여\n매번 변경되는 state를 반환하기 위함이다. 여기서 중요한 것은 저 listener 함수이다.\nlistener 함수는 대체 어디서 넣어주는 것일까?</p>\n<p>subscribe 함수에 console.log(listener.name) 를 출력해보면 다음과 같은 함수 이름이 나타난다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">handleStoreChange</code>\n        </deckgo-highlight-code>\n<h3>handleStoreChange</h3>\n<p><a href=\"https://github.com/facebook/react/blob/f74c5ccf9469d3389ce3a1ee3b54988049e235f7/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L110\">https://github.com/facebook/react/blob/f74c5ccf9469d3389ce3a1ee3b54988049e235f7/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L110</a></p>\n<p>handleStoreChange 해당 함수는 여기서 주입하고 있었다.\nzustand는 react에서 제공하는 useState, useReducer 없이도 useSyncExternalStore 훅을 통하여\nsubscribe 함수 의존성을 받아서 리액트에서 상태를 관리해주고 있었디.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const [{inst}, forceUpdate] = useState({inst: {value, getSnapshot}});\n\nuseEffect(() =&gt; {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({inst});\n    }\n    const handleStoreChange = () =&gt; {\n      // TODO: Because there is no cross-renderer API for batching updates, it&#39;s\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn&#39;t\n      // the case and print a warning in development?\n\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({inst}); &lt;----------------------------------- 상태 업데이트 코드\n      }\n    };\n    // Subscribe to the store and return a clean-up function.\n    return subscribe(handleStoreChange);\n  }, [subscribe]);</code>\n        </deckgo-highlight-code>\n<p>다음 포스트는 필자도 useSyncExternalStore 훅을 통해 커스텀 상태 관리를 구현하는 법을 게시 해보겠다.\n또한 useSyncExternalStore 훅 이전 zustand3 버전에서는 어떻게 상태 관리를 하는지 알아보겠다.</p>","frontmatter":{"title":"zustands는 어떻게 root provider 없이 상태관리를 할 수 있을까?(1)","date":"2024-05-19","description":"useSyncExternalStore, dai-shi 천재같다."}},"previous":{"fields":{"slug":"/타입 세이프하게 api를 호출해보자/"},"frontmatter":{"title":"타입 세이프하게 api를 호출해보기"}},"next":null},"pageContext":{"id":"9989787e-ba3f-5dbd-a3ff-c327cdcaf122","previousPostId":"f60ee1fa-8ff9-5794-b402-e21d567fc740","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}